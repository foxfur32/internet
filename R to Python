import re

def convert_function_signature(r_signature):
    # Example R signature: "model_x <- function(df)"
    # Convert to Python signature: "def model_x(df):"
    match = re.match(r"(\w+) *<- *function\((.*?)\)", r_signature)
    if match:
        func_name = match.group(1)
        params = match.group(2)
        return f"def {func_name}({params}):"
    return None

def convert_r_to_python(r_function):
    # Remove all new lines and extra spaces for better parsing
    r_function = re.sub(r'\s+', ' ', r_function.strip())

    # Split the function into signature and body
    parts = re.split(r" {", r_function, maxsplit=1)
    python_signature = convert_function_signature(parts[0])

    # Define translations from R to Python syntax within the function body
    translations = {
        "\.xbeta <- ": "xbeta=",
        "return\(\.xbeta\)": "df['xbeta'] = xbeta\n    return df['xbeta']",
        "with\(df, ": "",
        "}": "",
    }
    
    # Apply translations with regex for flexibility in handling spaces
    body = parts[1] if len(parts) > 1 else ""
    for r_syntax, py_syntax in translations.items():
        body = re.sub(r_syntax, py_syntax, body)

    # Handle operations and variables
    body = re.sub(r"(\d+) \+ (\d+) \* x", r"xbeta=\1 + \2*df['x']", body)
    body = re.sub(r" - (\d+) \* y", r" - \1*df['y']", body)

    # Prepare the full function as a Python function string
    python_lines = [python_signature]
    body_lines = body.split(';')
    for line in body_lines:
        if line.strip():
            python_lines.append("    " + line.strip())

    # Join all lines into a single Python function as a string
    python_function = "\n".join(python_lines)
    return python_function

# Example R function as a string with varied spacing
r_function_string = """
model_x <- function(df) {
  .xbeta <- with(df, {
    4 + 5 * x - 6 * y
  })
  return(.xbeta)
}
"""

# Convert R function to Python
python_function_string = convert_r_to_python(r_function_string)
print(python_function_string)
